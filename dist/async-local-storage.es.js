var t=Object.prototype.hasOwnProperty,e=Object.prototype.propertyIsEnumerable;function r(t){if(null==t)throw new TypeError("Sources cannot be null or undefined");return Object(t)}function o(e,r,o){var l=r[o];if(null!=l){if(t.call(e,o)&&(void 0===e[o]||null===e[o]))throw new TypeError("Cannot convert undefined or null to object ("+o+")");var c,a;!t.call(e,o)||(a=typeof(c=l),null===c||"object"!==a&&"function"!==a)?e[o]=l:e[o]=n(Object(e[o]),r[o])}}function n(r,n){if(r===n)return r;for(var l in n=Object(n))t.call(n,l)&&o(r,n,l);if(Object.getOwnPropertySymbols)for(var c=Object.getOwnPropertySymbols(n),a=0;a<c.length;a++)e.call(n,c[a])&&o(r,n,c[a]);return r}const l=(t,e)=>{const o=window.localStorage.getItem(t),l=JSON.parse(o),c=JSON.parse(e),a=JSON.stringify(function(t){t=r(t);for(var e=1;e<arguments.length;e++)n(t,arguments[e]);return t}({},l,c));window.localStorage.setItem(t,a)},c=(t,e)=>new Promise((r,o)=>{try{const o=t();e&&e(null,o),r(o)}catch(t){e&&e(t),o(t)}}),a=(t,e,r)=>Promise.all(t).then(t=>{const o=r?r(t):null;return e&&e(null,o),Promise.resolve(o)},t=>(e&&e(t),Promise.reject(t)));class s{static getItem(t,e){return c(()=>window.localStorage.getItem(t),e)}static setItem(t,e,r){return c(()=>{window.localStorage.setItem(t,e)},r)}static removeItem(t,e){return c(()=>window.localStorage.removeItem(t),e)}static mergeItem(t,e,r){return c(()=>{l(t,e)},r)}static clear(t){return c(()=>{window.localStorage.clear()},t)}static getAllKeys(t){return c(()=>{const t=window.localStorage.length,e=[];for(let r=0;r<t;r+=1){const t=window.localStorage.key(r);e.push(t)}return e},t)}static flushGetRequests(){}static multiGet(t,e){const r=t.map(t=>s.getItem(t));return a(r,e,e=>e.map((e,r)=>[t[r],e]))}static multiSet(t,e){const r=t.map(t=>s.setItem(t[0],t[1]));return a(r,e)}static multiRemove(t,e){const r=t.map(t=>s.removeItem(t));return a(r,e)}static multiMerge(t,e){const r=t.map(t=>s.mergeItem(t[0],t[1]));return a(r,e)}}export{s as default};
